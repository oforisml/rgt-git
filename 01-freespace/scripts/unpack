#!/bin/bash

# this script is supposed to decompress any kind of archive
# It can decompress one or more archives of different compression format at once

#.........................................................................

help="Usage:
	unpack [options] [file/directory....]
	Decompresses each file/files in a directory using the format they were compressed in.

     Options:
		-v, --verbose		print log while processing
		-r, --recursive		Unpack all files in directories recursively
		-h, --help			Display this help and exist"


# To add a decompression format, add a member of types_map_array.
# The member should be a pair [file extension]=command that unpacks it

types_map=( [gz]=gunzip [bz2]=bunzip2 [zip]=unzip [cmpr]=uncompress )

#Declaring boolean indicators of recursive and verbose
recursive=false
verbose=false

#Counters for the number of archives unpakced and failures
num_of_unpacked=0
num_of_failures=0

unpack_one_file()
{
	IFS='.' read -ra words <<<"$1"
	# check that the file has decompress format
	if [ ${#words[@]} -gt 1 ]; then
		arc_type=${words[-1]}
	else
		arc_type=""
	fi

	# Get the file name without the path for messages
	file_name=$(basename $1)

	#Unpack file if compressed by a known format, ignore otherwise
	if [ $arc_type ] && [ ${types_map[$arc_type]} ]; then
		if $verbose; then
			echo "Unpacking $file_name..."
		fi

	# Unpack using the correct decompression and supress log
	${types_map[$arc_type]} $1 > /dev/null

	# In case decompression fails, count as unpacking failure
		if [ $? -eq 0 ]; then
			num_of_unpacked=$((num_of_unpacked+1))
		else
			if $verbose; then
			echo "Failed to unpack $file_name"
			fi
			num_of_failures=$((num_of_failures+1))
		fi
	else
		if $verbose; then
			echo "Ignoring $file_name"
		fi
		num_of_failures=$((num_of_failures+1))
	fi
}


# This function unpacks every file in a folder
# and is recursive if -r was specified by user

unpack_folder()
{
	for item in $1; do
		if $recursive && [ -d "$item" ]; then
			unpack_folder $item"/*"
		elif [ -f "$item" ]; then
			unpack_one_file $item
		fi
	done
}

# Main script starts here

until [ -z "$1" ]; do
	case $1 in 
		-v|--verbose)
			verbose=true
			shift
			;;
		-r|--recursive)
			recursive=true
			shift
			;;
		-h|--help)
			echo -e "$help"
			exit 0
			;;
		-*)
			echo "ERROR: invalid option '$1'" > /dev/stderr
			;;
		*)
			# Checks if the parameter given is a direcotry or file
			# and deals with it accordingly
			if [ -d "$1" ]; then
				unpack_folder $1"/*"
			else
				unpack_folder $1
			fi
			shift
	esac
done
